# -*- coding: utf-8 -*-
"""Cybersecurity-PoC Agent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hnNLGS90GopXOhwHHIqxaGJERcajSMQJ

# Pocky Query Tool: Automated CVE PoC Search & Validation

A lightweight, web-scale agent that helps you find, filter, and fetch real-world PoC exploits â€” so you don't have to.

**Features:**
- Automatically searches multiple security-related websites
- Intelligently analyzes and extracts PoC code
- Automatically selects the most reliable PoC samples
- Supports collection of PoCs from multiple sources

[![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/DhivyaBharathy-web/PraisonAI/blob/main/examples/cookbooks/Pocky_Cybersecurity_PoC_Agent.ipynb)

# Install Dependencies
"""

!pip install praisonaiagents exa-py python-dotenv requests beautifulsoup4

"""# Set API Keys"""

import os

# Set your API keys here (replace with your actual keys)
os.environ["EXA_API_KEY"] = "your api key"
os.environ["OPENAI_API_KEY"] = "your api key"
os.environ["OPENAI_BASE_URL"] = "https://api.openai.com/v1"  # Optional, for custom OpenAI endpoints

"""# Tools (Core Functions)"""

import json
from openai import OpenAI
from exa_py import Exa

# Dummy/Minimal agent classes for notebook demo
class ValidationAgent:
    def __init__(self, input_json):
        self.input_json = input_json
    def run(self):
        # Dummy validation logic for notebook demo
        data = json.loads(self.input_json)
        return True if "attack_intent" in data and "poc_sample" in data else False

class AttackIntentAgent:
    def __init__(self, description):
        self.description = description
    def run(self):
        # Dummy intent extraction for notebook demo
        return f"Intent for: {self.description[:50]}..."

"""## YAML Prompt (Validation Example)
This is the prompt used for PoC validation.
"""

validation_prompt = """
You are a highly skilled technical assistant with deep expertise in PoC sample validation.

Given the attack intent of a CVE vulnerability and a PoC sample gathered from public sources, your task is to analyze whether the PoC correctly implements the intended attack behavior.

Specifically:
- Understand the CVE's attack intent, including the attack goal and the underlying exploitation mechanism.
- Analyze the PoC to determine whether it is designed to achieve this intent.
- Check whether the payloads, request structures, and overall logic of the PoC align with the described attack intent.
- You do not need to execute the PoC. Focus on static validation through reasoning and consistency.

Your output must be a JSON object with two fields:
- "valid": a boolean indicating whether the PoC correctly reflects the attack intent.
- "reasoning": a brief explanation of your judgment. If "valid" is false, the reasoning must clearly explain what is incorrect or inconsistent in the PoC compared to the attack intent, so that the PoC can be revised accordingly.
"""
print(validation_prompt)

"""# Main (Query and Validate a CVE PoC)"""

def run_pocky_for_cve(cve_id):
    # Example: Simulate fetching a description and PoC (replace with real logic)
    description = f"Description for {cve_id} (replace with real Exa/OpenAI search)"
    poc_sample = f"PoC code for {cve_id} (replace with real PoC search)"

    # Stage 2: Attack Intent
    intent = AttackIntentAgent(description).run()
    print(f"Attack Intent: {intent}")

    # Stage 3: Validation
    validation_input = json.dumps({"attack_intent": intent, "poc_sample": poc_sample}, indent=2)
    valid = ValidationAgent(validation_input).run()
    print(f"Validation Result: {valid}")
    if valid:
        print(f"PoC for {cve_id} is valid and ready to use.")
    else:
        print(f"PoC for {cve_id} failed validation.")

"""# Example Usage"""

run_pocky_for_cve("CVE-2023-4450")
